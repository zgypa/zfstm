#!/bin/bash

# 
# A tool to backup a workstation which is running mainly VM guests on a ZFS file system.
# 
# Makes use of zfSnap to take snapshots and zxfer to synchronize with external HDD
# External HDD should be encrypted using LUKS
# External HDD keyfile is saved locally on the worksation in plain text, because the
#  data the keyfile is protecting is data found on this computer itself.
# This script is called by cron in the cron.daily cron.hourly ... directories just by passing
#  a daily, hourly, weekly or monthly parameter to it.
# Changing backup device requires to manually change the UUID in this script.
# The script automatically unmounts itself in order to be ready to just get unplugged and not suffer.
# I have not tested how it survives a hard unpluggin of the backup drive.
#

# BKPPOOL="TOEKNEEBKP3"
# SRCVOL="SSD970EVO500GB/withsnaps"
LOCKFILE="/var/run/lock/${0##*/}.lock"
# UUID='7a418a09-520f-45e8-8a8f-102d2c6e57af'
VERBOSE=0
VERSION="0.2.0"

function print_help(){
	    cat << EOF
${0##*/} v${VERSION} by Toni Magni

Syntax:
${0##*/} [--config filename] [--keyfile filename] --source sourcevolume --bkppool destintionpool 
  --uuid device-uuid argument

OPTIONS:
  --source	= sourcezfsvolume
  --bkppool	= a ZFS pool that will receieve the backups
  --keyfile	= a keyfile to use to unlock a LUKS encrypted volume
	           Default is ~/<bkppool>.keyfile
  --uuid	= the UUID of the HDD to unlock and mount that would contain
		   the destinationpool
  --config	= config file to parse, instead of using arguments

ARGUMENTS:
  hourly       = Open, mount, snapshot with 1d TTL, backup, unmount and close.
  daily        = Open, mount, snapshot with 1w TTL, backup, unmount and close.
  weekly       = Open, mount, snapshot with 1m TTL, backup, unmount and close.
  monthly      = Open, mount, snapshot with 1y TTL, backup, unmount and close.
  backup       = Backup external drive.
  mount        = Open and mount external drive.
  unmount      = Unmount and close external drive (ready to be unplugged).
  snapshot TTL = Take snapshot with TTK as time to live. 

EXAMPLE:
${0##*/} --source SSD970EVO500GB/withsnaps --bkppool TOEKNEEBKP3 --uuid 7a418a09-520f-45e8-8a8f-102d2c6e57af hourly

EOF
}
for i in "$@"; do
	case "$1" in
		'--verbose')
			VERBOSE=1
			shift 1
			;;
		'--source')
			SRCVOL="$2"
			shift 2
			;;
		'--bkppool')
			BKPPOOL="$2"
			shift 2
			;;
		'--keyfile')
			KEYFILE="$2"
			shift 2
			;;
		'--uuid')
			UUID="$2"
			shift 2
			;;
		'--config')
			CONFIGFILE="$2"
			shift 2
			;;
	esac
done

if [ ! -z "$CONFIGFILE" ]; then
	. "$CONFIGFILE"
fi

if [ -z "$KEYFILE" ]; then
	KEYFILE="/${HOME}/${BKPPOOL}.keyfile"
fi

if [ "$1" == "hourly" ]; then
	ZFSNAP_TTL="1d"
elif [ "$1" == "daily" ]; then
	ZFSNAP_TTL="1w"
elif [ "$1" == "weekly" ]; then
	ZFSNAP_TTL="1m"
elif [ "$1" == "monthly" ]; then
	ZFSNAP_TTL="1y"
elif [ "$1" == "mount" ]; then
	ACTION="mount"
elif [ "$1" == "unmount" ]; then
	ACTION="unmount"
elif [ "$1" == "backup" ]; then
	ACTION="backup"
elif [ "$1" == "snapshot" ]; then
	ACTION="snapshot"
else
	echo "ERROR: invalid ARGUMENT $1"
	print_help
	exit 1
fi

function unlock(){
	rm ${LOCKFILE} 2> /dev/null
}

function error(){
	echo ERROR: $@
	unlock
}

function debug(){
	if [ $VERBOSE -eq 1 ]; then
		echo DEBUG: $@
	fi
}

function is_locked(){
	if [ -f ${LOCKFILE} ]; then
		return 0
	else
		return 1
	fi
}

function lock(){
	if is_locked; then
		error "Cannot lock. Already locked"
		exit 2
	else
		touch ${LOCKFILE}
	fi
}

function mount_backup_drive(){
	if [ $ENCRYPTION ]; then
		debug "Opening and mounting ${DEVICE} with ${KEYFILE}"
		# cryptsetup exits with 5 when device is already open
		cryptsetup open --type luks --key-file ${KEYFILE} "$DEVICE" "$MAPPER" || if [ $? -ne 5 ]; then { error "Got exit code $? trying to open LUKS volume" && exit 3 ; } fi
	else
		debug "No keyfile specified. Assuming drive without encryption"
	fi
	if ! zpool list ${BKPPOOL} > /dev/null 2>&1; then 
		debug "importing zpool ${BKPPOOL}"
		zpool import ${BKPPOOL} || { error "Got exit code $? trying to import pool" && exit 4; }
	else
		debug "zpool ${BKPPOOL} already imported"
	fi
}

function unmount_backup_drive(){
	debug "Unmounting backup pool ${BKPPOOL}"
	# If normal unmount fail, resort to forceful
	zpool export ${BKPPOOL} || zpool export -f ${BKPPOOL} || { error "Got exit code $? trying to unmount ${BKPPOOL}" && exit 5; } 
	if [ $ENCRYPTION ]; then 
		debug "Closing LUKS volume ${MAPPER}"
		cryptsetup close ${MAPPER} || { error "Got exit code $? trying to close ${MAPPER}" && exit 6; }
	fi
	debug "Spinning down ${DEVICE}"
	hdparm -y ${DEVICE} || { error "Got exit code $? trying to spin down HDD." && exit 7; }
}

function backup(){
	echo "Backing up to external pool"
	if zfs list ${BKPPOOL} > /dev/null 2>&1; then 
		zxfer -dFkPv -R ${SRCVOL} -D 'bar -s %%size%% --title %%title%%' ${BKPPOOL}
	else 
		echo "Drive not mounted"; 
	fi
}

function make_snapshot(){
	echo "Making Snapshot" 
	/usr/sbin/zfSnap -d -a ${1} -r ${SRCVOL}
}

if is_locked; then
	error "lockfile found"
	exit 2
fi

lock

DEVICE="/dev/disk/by-uuid/${UUID}"
MAPPER="luks-${UUID}"

if [ -r "${KEYFILE}" ]; then
	echo "Keyfile is readable. Proceeding with encryption"
	ENCRYPTION=1
else
	echo "${KEYFILE} either not specified or not readable."
	unset ENCRYPTION
fi


if [ "${ACTION}" == "mount" ]; then
	mount_backup_drive
elif [ "${ACTION}" == "unmount" ]; then
	unmount_backup_drive
elif [ "${ACTION}" == "backup" ]; then
	backup
elif [ "${ACTION}" == "snapshot" ]; then
	if [ -z $2 ]; then
		print_help
		exit 1
	fi
	make_snapshot $2
else
	mount_backup_drive || { error "Cannot mount backup drive. Exiting." && exit 11; }  
	make_snapshot ${ZFSNAP_TTL}|| { error "Error while creating snapshot. Exiting." && exit 12; }
	backup || error "while creating backup" 
	unmount_backup_drive || { error "Error while closing backup drive" && exit 13; }
fi

unlock
